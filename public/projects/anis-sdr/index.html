<!doctype html><html lang=en dir=auto data-theme=dark><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>anis-sdr | jack payne</title><meta name=keywords content><meta name=description content="Building an adaptive multi-notch filter for Software Defined Radios"><meta name=author content="Jack Payne"><link rel=canonical href=http://localhost:1313/projects/anis-sdr/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.420d33339610a5270b7098fee757d281066418714c6b42d6bdcdb49dbd2dde0b.css integrity="sha256-Qg0zM5YQpScLcJj+51fSgQZkGHFMa0LWvc20nb0t3gs=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/static/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/favicon-16x16.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/projects/anis-sdr/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0},svg:{fontCache:"global"}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><meta property="og:url" content="http://localhost:1313/projects/anis-sdr/"><meta property="og:site_name" content="jack payne"><meta property="og:title" content="anis-sdr"><meta property="og:description" content="Building an adaptive multi-notch filter for Software Defined Radios"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="projects"><meta property="article:published_time" content="2026-01-02T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-02T00:00:00+00:00"><meta property="og:image" content="http://localhost:1313/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/"><meta name=twitter:title content="anis-sdr"><meta name=twitter:description content="Building an adaptive multi-notch filter for Software Defined Radios"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"http://localhost:1313/projects/"},{"@type":"ListItem","position":2,"name":"anis-sdr","item":"http://localhost:1313/projects/anis-sdr/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"anis-sdr","name":"anis-sdr","description":"Building an adaptive multi-notch filter for Software Defined Radios","keywords":[],"articleBody":"I wanted to familiarize myself with the GNURadio environment and creatively implement some adaptive filter ideas, so I chose to write a flexible custom C++ module for spike detection and removal. The filter can track and attenuate multiple interferers as they overlap and drift around the frequency spectrum. It works on complex basebands, so it can be used to recover modulated RF signals as well as real-valued signals like EEG data.\nHere is the Github repo for the project if you’d like to explore it.\narchitecture I decided on a cascaded IIR structure to get deep attenuation of multiple interference spikes. Wanting to get clever with the tracking, I drew inspiration from a family of adaptive filters that update themselves based on the derivatives of their own equations in order to do it completely in the time domain. Most of the legwork can be done without expensive Fourier transform operations this way.\nWhile I originally hoped this idea would be sufficient, it turned out that occasional forays into the frequency domain were still needed to detect spikes based on an amplitude threshold. When a notch is placed at a spike, it can follow the spike around via gradient descent without recomputing its central frequency. From this observation comes the two stages of the filter:\nGlobal Detection Stage: intermittently computes an FFT across a circular buffer of samples and detects newly emerged interference spikes as judged by a threshold multiplier of the mean input amplitude. New IIR notches are spawned at unhandled spikes, and old ones are pruned. Local Tracking Stage: once a notch is placed around an interference source, it performs a continuous update of the gradient of the output power of the overall filter with respect to a positive change in its center frequency $\\omega$. This allows it to make decisions about how to adjust its own frequency in order to track drifting interferers without needing FFT. tracking stage Each notch is a first order IIR $$y[n]=x[n]-ax[n-1]+ray[n-1]$$centered at $w$, so $a=e^{jw}$. The zero sits on the unit circle for maximum attenuation, while the pole sits $1-r$ away from the zero and determines the bandwidth of the filter as configured by the user. This resembles the so-called CPZ-ANF architecture (constrained pole zero adaptive notch filter).\n$p[n]=|y[n]|^2$ is the instantaneous power of the output after the filter is applied. By minimizing this based on the value of $\\omega$, we can find the frequency where the filter attenuates the input the most – i.e, the frequency of the interference source!\nAt a given moment, we want to determine whether ${p}[n]$ increases or decreases when we increment $\\omega$ by a small step. By making this determination and then choosing the direction that decreases $p[n]$, we will find the frequency of the narrowband interference. When $\\omega$ is incremented based on its effect on ${p}$, it naturally follows the transition bandwidth of the spike to its center.\nIn order to understand how $p[n]$ is affected by a change in $\\omega$, consider its partial derivative with respect to $\\omega$. Since $p$ depends on the filter output $y[n]$, we can find $$\\frac{\\partial y[n]}{\\partial \\omega}=g[n]=-(ja)x[n-1] +r(ja)y[n-1]+rag[n-1]$$ Given $p[n]=|y|^2=yy^{*}$ (from the definition of the squared magnitude of a complex function given complex conjugate y*), $$\\frac{\\partial p[n]}{\\partial \\omega}=\\frac{\\partial (yy*)}{\\partial \\omega}=2ℜ(gy*)$$ Thus:\nIf the value of $2ℜ(gy*)$ is positive, then output power increases if $\\omega$ increases, so we decrease $\\omega$ If the value of $2ℜ(gy*)$ is negative, then output power decreases if $\\omega$ increases, so we increase $\\omega$ So given a small step value $\\omega_\\triangle$, we update $$\\omega \\leftarrow \\omega-\\omega_\\triangle( \\frac{\\partial p}{\\partial \\omega})$$\nPlacing the notches at detected spikes and then letting them perform this computation per-sample is the essence of the filter.\nsome development notes At one prototype stage, the adaptive filter was able to track and settle on a single stationary interferer. However, the use of a slower (every 8 sample) update rate for $\\omega$ produced spectral lines at $f_s/8$ intervals. I fixed this by simply updating $\\omega$ per-sample with no significant performance penalty, but it was a good lesson learned about the consequences of introducing period behavior into a filter function. I also imposed an upper bound of $50 Hz$ on how much $\\omega$ could move per update, since this also contributed to some sideband generation.\nWhen multiple notches were implemented, sidebands also emerged despite smooth tracking. When I inspected the $\\omega$ values for each notch, it seemed like dithering was being caused by very small oscillations of the notch frequency even when placed correctly in theory, contributing to both spurs and insufficient attenuation. Some approaches I tried:\nIntroducing a deadband (minimum $\\omega_\\triangle$) of 0.02 Hz required to update $\\omega$. Larger update requests would still be made even if the the notch was placed correctly, so a minimal omega was not sufficient to predict meaningful updates. I tried a latch mechanism where enough consecutive small requests (\u003c about 10Hz) ’locks’ the notch frequency, while enough consecutive larger requests (\u003e 20Hz) ‘unlocks’ the notch and allows it to adapt meaningfully again. This introduced further issues – notches were unmotivated to adapt at all even when playing with thresholds, often falsely converging by settling on non-ideal frequencies due to latch triggering when its gradient was small. While the notches were stationary enough to prevent spurs, this resulted in very poor attenuation. I decided to try replacing the latch with a more elegant update smoother. This would use the gradient to persistently declare a target $\\omega_\\triangle$ and then continuously slew the update towards this value in order to prevent spectral lines emerging from discontinuously varying updates. By tuning the smoothing parameters, I achieved a maximum amplitude of -75dB for the interferers and sidebands in the worst (closest) case, and very successful attenuating when interferers were farther apart. results One unanticipated benefit of the cascaded architecture is that as the number of notches allowed to generate increases beyond the number of interferers, the extra notches will work to exponentially attenuate the small spurs still being produced by the primary notches. By allowing for a few extras beyond the number of spikes anticipated and with some threshold tuning, nearly perfect spectral power recovery was achieved across most test cases for various signal types.\nnoise satellite EEG ","wordCount":"1033","inLanguage":"en","image":"http://localhost:1313/","datePublished":"2026-01-02T00:00:00Z","dateModified":"2026-01-02T00:00:00Z","author":{"@type":"Person","name":"Jack Payne"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/projects/anis-sdr/"},"publisher":{"@type":"Organization","name":"jack payne","logo":{"@type":"ImageObject","url":"http://localhost:1313/static/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=http://localhost:1313/projects/ title=projects><span>projects</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li><li><a href=http://localhost:1313/resume.pdf title=resume><span>resume</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/projects/>Projects</a></div><h1 class="post-title entry-hint-parent">anis-sdr</h1><div class=post-meta><span title='2026-01-02 00:00:00 +0000 UTC'>January 2, 2026</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>1033 words</span>&nbsp;·&nbsp;<span>Jack Payne</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/%3cpath_to_repo%3e/content/projects/anis-sdr/index.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><div class=post-content><p>I wanted to familiarize myself with the GNURadio environment and creatively implement some adaptive filter ideas, so I chose to write a flexible custom C++ module for spike detection and removal. The filter can track and attenuate multiple interferers as they overlap and drift around the frequency spectrum. It works on complex basebands, so it can be used to recover modulated RF signals as well as real-valued signals like EEG data.</p><p>Here is the <a href=https://github.com/jacklpayne>Github repo</a> for the project if you&rsquo;d like to explore it.</p><h1 id=architecture>architecture<a hidden class=anchor aria-hidden=true href=#architecture>#</a></h1><p>I decided on a cascaded IIR structure to get deep attenuation of multiple interference spikes. Wanting to get clever with the tracking, I drew inspiration from a family of adaptive filters that update themselves based on the derivatives of their own equations in order to do it completely in the time domain. Most of the legwork can be done without expensive Fourier transform operations this way.</p><p>While I originally hoped this idea would be sufficient, it turned out that occasional forays into the frequency domain were still needed to detect spikes based on an amplitude threshold. When a notch is placed at a spike, it can follow the spike around via gradient descent without recomputing its central frequency. From this observation comes the two stages of the filter:</p><ol><li><strong>Global Detection Stage</strong>: intermittently computes an FFT across a circular buffer of samples and detects newly emerged interference spikes as judged by a threshold multiplier of the mean input amplitude. New IIR notches are spawned at unhandled spikes, and old ones are pruned.</li><li><strong>Local Tracking Stage</strong>: once a notch is placed around an interference source, it performs a continuous update of the <em>gradient</em> of the output power of the overall filter with respect to a positive change in its center frequency $\omega$. This allows it to make decisions about how to adjust its own frequency in order to track drifting interferers without needing FFT.</li></ol><h1 id=tracking-stage>tracking stage<a hidden class=anchor aria-hidden=true href=#tracking-stage>#</a></h1><p>Each notch is a first order IIR $$y[n]=x[n]-ax[n-1]+ray[n-1]$$centered at $w$, so $a=e^{jw}$. The zero sits on the unit circle for maximum attenuation, while the pole sits $1-r$ away from the zero and determines the bandwidth of the filter as configured by the user. This resembles the so-called <strong>CPZ-ANF</strong> architecture (constrained pole zero adaptive notch filter).</p><p>$p[n]=|y[n]|^2$ is the <strong>instantaneous power</strong> of the output after the filter is applied. By minimizing this based on the value of $\omega$, we can find the frequency where the filter attenuates the input the most &ndash; i.e, the frequency of the interference source!</p><p>At a given moment, we want to determine whether ${p}[n]$ increases or decreases when we increment $\omega$ by a small step. By making this determination and then <em>choosing the direction that decreases</em> $p[n]$, we will find the frequency of the narrowband interference. When $\omega$ is incremented based on its effect on ${p}$, it naturally follows the transition bandwidth of the spike to its center.</p><p>In order to understand how $p[n]$ is affected by a change in $\omega$, consider its partial derivative with respect to $\omega$. Since $p$ depends on the filter output $y[n]$, we can find
$$\frac{\partial y[n]}{\partial \omega}=g[n]=-(ja)x[n-1] +r(ja)y[n-1]+rag[n-1]$$
Given $p[n]=|y|^2=yy^{*}$ (from the definition of the squared magnitude of a complex function given complex conjugate y*), $$\frac{\partial p[n]}{\partial \omega}=\frac{\partial (yy*)}{\partial \omega}=2ℜ(gy*)$$
Thus:</p><ol><li>If the value of $2ℜ(gy*)$ is <em>positive</em>, then output power <em>increases</em> if $\omega$ increases, so we <em>decrease</em> $\omega$</li><li>If the value of $2ℜ(gy*)$ is <em>negative</em>, then output power <em>decreases</em> if $\omega$ increases, so we <em>increase</em> $\omega$</li></ol><p>So given a small step value $\omega_\triangle$, we update $$\omega \leftarrow \omega-\omega_\triangle( \frac{\partial p}{\partial \omega})$$</p><p>Placing the notches at detected spikes and then letting them perform this computation per-sample is the essence of the filter.</p><h1 id=some-development-notes>some development notes<a hidden class=anchor aria-hidden=true href=#some-development-notes>#</a></h1><p><img loading=lazy src=/projects/anis-sdr/images/t1.png>
At one prototype stage, the adaptive filter was able to track and settle on a single stationary interferer. However, the use of a slower (every 8 sample) update rate for $\omega$ produced spectral lines at $f_s/8$ intervals. I fixed this by simply updating $\omega$ per-sample with no significant performance penalty, but it was a good lesson learned about the consequences of introducing period behavior into a filter function. I also imposed an upper bound of $50 Hz$ on how much $\omega$ could move per update, since this also contributed to some sideband generation.</p><p><img loading=lazy src=/projects/anis-sdr/images/t2.png>
When multiple notches were implemented, sidebands also emerged despite smooth tracking. When I inspected the $\omega$ values for each notch, it seemed like dithering was being caused by very small oscillations of the notch frequency even when placed correctly in theory, contributing to both spurs and insufficient attenuation. Some approaches I tried:</p><ul><li>Introducing a deadband (minimum $\omega_\triangle$) of 0.02 Hz required to update $\omega$. Larger update requests would still be made even if the the notch was placed correctly, so a minimal omega was not sufficient to predict meaningful updates.</li><li>I tried a latch mechanism where enough consecutive small requests (&lt; about 10Hz) &rsquo;locks&rsquo; the notch frequency, while enough consecutive larger requests (> 20Hz) &lsquo;unlocks&rsquo; the notch and allows it to adapt meaningfully again. This introduced further issues &ndash; notches were unmotivated to adapt at all even when playing with thresholds, often falsely converging by settling on non-ideal frequencies due to latch triggering when its gradient was small. While the notches were stationary enough to prevent spurs, this resulted in very poor attenuation.</li><li>I decided to try replacing the latch with a more elegant update smoother. This would use the gradient to persistently declare a target $\omega_\triangle$ and then continuously <em>slew</em> the update towards this value in order to prevent spectral lines emerging from discontinuously varying updates. By tuning the smoothing parameters, I achieved a maximum amplitude of -75dB for the interferers and sidebands in the worst (closest) case, and very successful attenuating when interferers were farther apart.
<img loading=lazy src=/projects/anis-sdr/images/t3.png></li></ul><h1 id=results>results<a hidden class=anchor aria-hidden=true href=#results>#</a></h1><p>One unanticipated benefit of the cascaded architecture is that as the number of notches allowed to generate increases beyond the number of interferers, the extra notches will work to exponentially attenuate the small spurs still being produced by the primary notches. By allowing for a few extras beyond the number of spikes anticipated and with some threshold tuning, nearly perfect spectral power recovery was achieved across most test cases for various signal types.</p><h3 id=noise>noise<a hidden class=anchor aria-hidden=true href=#noise>#</a></h3><p><img loading=lazy src=/projects/anis-sdr/images/noisetest.gif></p><h3 id=satellite>satellite<a hidden class=anchor aria-hidden=true href=#satellite>#</a></h3><p><img loading=lazy src=/projects/anis-sdr/images/satellitetest.gif></p><h3 id=eeg>EEG<a hidden class=anchor aria-hidden=true href=#eeg>#</a></h3><p><img loading=lazy src=/projects/anis-sdr/images/eegtest.png></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://localhost:1313/>jack payne</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>